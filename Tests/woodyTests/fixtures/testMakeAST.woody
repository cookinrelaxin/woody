# Should be unreferenced to
# whitespace => ( u000A | u000D | u000D u000A )
#             | ("//" (U \ { u000A, u000D }) (u000A | u000D | u000D u000A))
#             | ("/*" U "*/")
#             | { u0000, u0009, u000B, u000C, u0020 };
#
# keyword => ("associatedtype" | "class" | "deinit" | "enum"
#                      | "extension" | "fileprivate" | "func" | "import"
#                      | "init" | "inout" | "internal" | "let" | "open"
#                      | "operator" | "private" | "protocol" | "public"
#                      | "static" | "struct" | "subscript" | "typealias"
#                      | "var")
#
#           | ("break" | "case" | "continue" | "default" | "defer"
#                  | "do" | "else" | "fallthrough" | "for" | "guard"
#                  | "if" | "in" | "repeat" | "return" | "switch"
#                  | "where" | "while");
#
whitespace => whitespace_item+;
keyword => declaration_keyword | statement_keyword | expression_or_type_keyword
         | pattern_keyword | hash_keyword | contextual_keyword;

whitespace => whitespace_item+;

whitespace_item -> line_break;
whitespace_item -> comment;
whitespace_item -> multiline_comment;
whitespace_item -> { u0000, u0009, u000B, u000C, u0020 };

line_break -> u000A;
line_break -> u000D;
line_break -> u000D u000A;

comment           -> "//" commentText lineBreak;
multiline_comment -> "/*" U "*/";
commentText       -> commentTextItem+;

commentTextItem -> U \ { u000A, u000D };

keyword => declaration_keyword | statement_keyword | expression_or_type_keyword
         | pattern_keyword | hash_keyword | contextual_keyword;

declaration_keyword -> "associatedtype" | "class" | "deinit" | "enum"
                     | "extension" | "fileprivate" | "func" | "import"
                     | "init" | "inout" | "internal" | "let" | "open"
                     | "operator" | "private" | "protocol" | "public"
                     | "static" | "struct" | "subscript" | "typealias"
                     | "var";

statement_keyword -> "break" | "case" | "continue" | "default" | "defer"
                   | "do" | "else" | "fallthrough" | "for" | "guard"
                   | "if" | "in" | "repeat" | "return" | "switch"
                   | "where" | "while";

expression_or_type_keyword -> "as" | "Any" | "catch" | "false" | "is"
                            | "nil" | "rethrows" | "super" | "self"
                            | "Self" | "throw" | "throws" | "true"
                            | "try";

pattern_keyword -> '_;

contextual_keyword -> "associativity" | "convenience" | "dynamic"
                    | "didSet" | "final" | "get" | "infix" | "indirect"
                    | "lazy" | "left" | "mutating" | "none" | "nonmutating"
                    | "optional" | "override" | "postfix" | "precedence"
                    | "prefix" | "Protocol" | "required" | "right" | "set"
                    | "Type" | "unowned" | "weak" | "willSet";
